import os
import pandas as pd
import pytest
import yaml
from metcalcpy.agg_stat import AggStat

def test_reformatted_input():
    '''
      Test that the reformatted input generates output that doesn't have NA or none for
      the RMSE or SPREAD_PLUS_OERR statistics.

      The reformatted input was generated by METdataio's METreformat module for the ECNT linetype.

    :return:
    '''

    # Read in the YAML config file
    config_file = "./rrfs_ecnt_config_agg_stat.yaml"

    with open(config_file, 'r') as stream:
        try:
            parms: dict = yaml.load(stream, Loader=yaml.FullLoader)

        except yaml.YAMLError as exc:
            print(exc)

    # Calculate the aggregation statistics using the specified YAML config file and reformatted
    # ECNT linetype data (reformatted via the METdataio METreformat module)
    AGG_STAT = AggStat(parms)
    AGG_STAT.calculate_stats_and_ci()

    output_file = parms['agg_stat_output']
    df:pd.DataFrame = pd.read_csv(output_file, sep="\t")

    # Verify that the ECNT_RMSE and ECNT_SPREAD_PLUS_OERR stat_values are NOT
    # NA (NaN) values.
    rmse_only:pd.DataFrame = df.loc[ df['stat_name'] == 'ECNT_RMSE' ]
    spread_plus_oerr_only:pd.DataFrame = df.loc[ df['stat_name'] == 'ECNT_SPREAD_PLUS_OERR' ]

    num_rmse_rows = rmse_only.shape[0]
    num_spread_plus_oerr_rows = spread_plus_oerr_only.shape[0]

    # Remove NA (NaN) from and stat_name columns in the rmse_only and spread_plus_oerr_only
    # dataframes.  If any exist, the total number of rows will be reduced and the test fails, as this
    # input data should only produce valid stat_name values.
    clean_rmse = rmse_only[rmse_only['stat_value'].notna()]
    clean_spread_plus_oerr = spread_plus_oerr_only[ spread_plus_oerr_only['stat_value'].notna()]
    num_cleaned_rmse = clean_rmse.shape[0]
    num_cleaned_spread_plus_oerr = clean_spread_plus_oerr.shape[0]

    assert num_rmse_rows == num_cleaned_rmse
    assert num_spread_plus_oerr_rows == num_cleaned_spread_plus_oerr

    # Clean up the aggregation output file
    os.remove(output_file)




